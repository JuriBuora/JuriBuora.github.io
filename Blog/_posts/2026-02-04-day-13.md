---
layout: post
title: "üìÖ Day 13 ‚Äì SSH and Networking Flow Between VMs"
date: 2026-02-04
categories: blog
tags:
  - Linux
  - Networking
  - CommandLine
  - SSH
  - LearningProcess
---

## üéØ Goal

Understand and practice real network communication between two Linux machines by chaining together SSH, SCP, and HTTP file transfers, and reason clearly about where each protocol fits in the networking flow.

---

## ‚úÖ What I Did

### Network Discovery

- Identified the correct network interface on Ubuntu using:
    
    ```bash
    ip a
    ```
    
- Learned to ignore non-relevant interfaces:
    
    - `lo` (loopback)
        
    - `docker0` (internal container bridge)
        
- Correctly selected the active interface:
    
    - `enp0s5` ‚Üí `10.211.55.5/24`
        
- Recognized the `10.211.x.x` range as **Parallels NAT networking**, confirming VM-to-VM reachability
    

### Connectivity Verification

- Verified Layer-3 connectivity from Kali using:
    
    ```bash
    ping 10.211.55.5
    ```
    
- Confirmed that basic IP networking was functional before attempting higher-level protocols
    

### Secure Remote Access (SSH)

- Connected from **Kali ‚Üí Ubuntu** using:
    
    ```bash
    ssh parallels@10.211.55.5
    ```
    
- Verified successful authentication by observing the remote Ubuntu shell prompt
    
- Reinforced that SSH provides an **encrypted remote control channel**, not just a login
    

### Secure File Transfer (SCP)

- Created a test file on Kali:
    
    ```bash
    echo "hello from kali" > testfile.txt
    ```
    
- Transferred it securely to Ubuntu using:
    
    ```bash
    scp testfile.txt parallels@10.211.55.5:/home/parallels/
    ```
    
- Verified file integrity and contents on Ubuntu
    

### Application-Layer File Serving (HTTP)

- Served files from Ubuntu using Python‚Äôs built-in HTTP server:
    
    ```bash
    python3 -m http.server 8000
    ```
    
- Understood that this exposes the current directory over **unencrypted HTTP**
    
- Intentionally left the server running only for the duration of the test
    

### Client-Side Retrieval (wget)

- Downloaded the file from Kali using:
    
    ```bash
    wget http://10.211.55.5:8000/testfile.txt
    ```
    
- Verified that the file contents matched the original
    

### Cleanup

- Properly stopped the HTTP server using `Ctrl + C`
    
- Reinforced the habit of never leaving temporary services running
    

---

## ‚úÖ What Worked

- Identifying the correct interface made the rest of the exercise straightforward
    
- Verifying connectivity with `ping` prevented wasted debugging time
    
- SSH and SCP worked reliably once IP-level networking was confirmed
    
- Python‚Äôs HTTP server was extremely effective for short-lived file transfers
    
- The full Kali ‚Üí Ubuntu ‚Üí Kali round trip clarified protocol layering
    

---

## ‚ùå What Didn‚Äôt

- Initial temptation to overthink DNS instead of starting with raw IP connectivity
    
- Having to stay disciplined about stopping temporary services
    

---

## üß† Key Takeaways

- Networking is layered: IP first, then transport, then application protocols
    
- SSH encrypts everything after connection establishment, including file transfers
    
- SCP is simply SSH applied to file movement
    
- HTTP is easy to stand up, but dangerous if exposed without intent or controls
    
- Correct interface selection is a foundational troubleshooting skill
    

---

## ‚ùì Questions

- When is SCP preferable to HTTP-based transfers in real environments?
    
- How would this flow change across routed or firewalled networks?
    
- What visibility do defenders retain once traffic is encrypted?