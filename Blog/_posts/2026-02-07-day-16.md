---
layout: post
title: "üìÖ Day 16 ‚Äî Linux Privilege Escalation: SUID, SGID, Sticky Bit (Foundations)"
date: 2026-02-07
categories: blog
tags:
  - Linux
  - Permissions
  - Processes
  - LinuxFundamentals
  - Cybersecurity
  - Labs
---

[text](obsidian://open?vault%3DObsidian%20Vault%26file%3Dz%20STUDYING%2FCYBERSECURITY%2Fz%20DAILY%2Fscreenshots%20daily%2FScreenshot%202026-02-07%20at%2017.36.57.png)

## üéØ Goal

Build a **correct mental model** of Linux privilege escalation foundations by understanding:

- What **SUID**, **SGID**, and **Sticky Bit** actually do
- How Linux **really** handles execution identity
- Why some configurations are dangerous ‚Äî and others only *look* dangerous
- How attackers enumerate and reason about privilege boundaries

This day was about **mechanics, not exploits**.

---

## üß† Key Concepts (Before Touching Commands)

Linux privilege escalation is not magic.  
It is about **execution context**.

Every process has:
- a **real UID/GID** (who launched it)
- an **effective UID/GID** (whose permissions it runs with)

Special permission bits exist to *intentionally* bend this rule ‚Äî and that‚Äôs where things can go wrong.

---

## üîß Lab Work & Observations

### 1Ô∏è‚É£ SUID on Scripts (The Trap)

I created a simple shell script and set the SUID bit on it.

Even though:
- the filesystem showed the `s` bit
- `file` reported it as `setuid`

Linux **did not** change the effective UID at runtime.

**Why?**
- Modern Linux kernels **ignore SUID on scripts**
- Interpreters + environment variables + race conditions are inherently unsafe

‚û°Ô∏è This is not a bug.  
‚û°Ô∏è This is a **security decision**.

**Key insight:**  
> Filesystem permissions ‚â† kernel execution behavior.

---

### 2Ô∏è‚É£ Real SUID: Compiled Binary

I then built a **small C program** printing:
- real UID
- effective UID

When the binary was:
- compiled (ELF)
- owned by `root`
- marked with SUID

Running it as a normal user clearly showed:

- real UID = my user
- effective UID = `root`

üî• **This is real SUID behavior**.

No guessing. No theory. Just mechanics.

---

### 3Ô∏è‚É£ Enumerating SUID Files (Attacker View)

I enumerated SUID binaries using:

```bash
find / -perm -4000 2>/dev/null
```````


Important realization:

- Most SUID binaries are **expected and hardened**
    
- Attackers don‚Äôt panic ‚Äî they **filter**
    

I analyzed examples like:

- `Xorg.wrap` ‚Üí legacy, historically vulnerable, environment-dependent
    
- `chfn` ‚Üí boring but input-parsing (interesting in older systems)
    
- `snap-confine` ‚Üí security boundary creator (high-impact if broken)
    

**Lesson:**

> The most interesting SUID binaries are often the ones enforcing security, not the obvious ones.

---

### 4Ô∏è‚É£ SGID: Quiet Privilege Changes

SGID doesn‚Äôt usually give root ‚Äî but it can:

- grant access to powerful groups
    
- enable sideways privilege escalation
    
- act as a stepping stone
    

Enumerated with:

find / -perm -2000 2>/dev/null

Key takeaway:

> SGID is a _horizontal_ privilege change ‚Äî subtle, but real.

---

### 5Ô∏è‚É£ Sticky Bit: Damage Containment

Checked `/tmp` permissions:

`ls -ld /tmp`

Observed:

- world-writable directory
    
- sticky bit enabled (`t`)
    

Sticky bit:

- does **not** grant privileges
    
- prevents users from deleting each other‚Äôs files
    

Attackers don‚Äôt exploit sticky bit ‚Äî  
they exploit its **absence**.

---

### 6Ô∏è‚É£ PATH, Cron, Services (Previewed, Not Mastered)

I also introduced:

- writable directories in `$PATH`
    
- cron jobs
    
- root-owned services
    

Important realization:

> These are **not vulnerabilities on their own**.

They become dangerous **only when chained** with:

- SUID binaries
    
- unsafe scripts
    
- trusted execution contexts
    

This part needs deeper, slower treatment ‚Äî scheduled for later.

---

## üß© Mental Model (The Real Outcome)

By the end of the day, the model became clear:

- **SUID** ‚Üí vertical privilege jump (dangerous)
    
- **SGID** ‚Üí horizontal privilege shift (subtle)
    
- **Sticky bit** ‚Üí containment, not escalation
    
- **PATH / cron / services** ‚Üí exploit _enablers_, not exploits
    

Privilege escalation is not about running commands.  
It‚Äôs about **breaking trust boundaries**.

---

## üß† Lessons Learned

**What worked**

- Building my own binaries instead of trusting examples
    
- Verifying everything with `id`, `file`, and real output
    
- Thinking like an attacker, not a tutorial follower
    

**What broke**

- Initial assumptions about SUID on scripts
    
- Treating enumeration commands as ‚Äúfind exploit buttons‚Äù
    

**Why it broke**

- Confusing filesystem metadata with kernel execution rules
    
- Not separating _capability_ from _exploitability_
    

**Fix / takeaway**

- Always verify **who a program actually runs as**
    
- Treat enumeration as **judgment training**, not exploit hunting
    
- Slow down when concepts start chaining ‚Äî depth beats speed
    